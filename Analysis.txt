== NANA ASIEDU-AMPEMS'S CW ANALYSIS ==
== (Optional read) Intoduction ==
I have tried to remove a lot of duplication in my solution to make my code easier
to manage and read. As you can see my solution only uses 1 system file "system23456"
(yes I know the name is ugly!) to perform systems 2 through to 6. Duplication has also
been reduced in all process files. A Makefile has been created to make it easy to
test my program with various outputs (check the file "README.txt" for details)

== (Optional read) Approach ==
Below is a general algorithm of how my solution works:

System:
> The system process sets up N processes with the correct parameters and sends each of them
commands to start.
> System waits for each process to confirm the completion of their tasks and then
calls halt() to end the execution of the processes (it timesout if process takes too long
to confirm and calls halt()).

App component:
> Start timer to end task after 'Timeout' miliseconds
> Initialise a mapping from process number to 0 (amount received from the process).
  Also create a 'Send' variable to store number of messages broadcasted.
*> Prioritise the receipt of a timeout message, if such a message is in the queue
   , end the task and return data
>  If there is no timeout, check message queue for either a "broadcast message" command
   or a delivery of a broadcasted message from another process (or itself).
   In either case, perform the task then increment relevant variables/maps and continue to step (*>).
   Broadcasting should only be done if max messages hasn't been exceeded or it equals 0.
   If a message was broadcasted (or not), The process should send itself a "broadcast message" command.
> If there is no message in the queue what so ever, send a "broadcast message" command and continue to step (*>).

== Insights ==
To make sure my code is non deterministic, I had my process send itself a command to broadcast.
This meant that their was a race condition on whether the process will receive the
broadcast command first or a delivery of a broadcasted messaged first.
This leads to non determinism, though I realise this is unnecessary as the message queue size
is undeterministic anyway. I implemented it this way has it made more sense to me as well as the
fact that receiving message does not hinder the action of broadcasting.

This has lead to a possible starvation problem where too many messages are broadcasted but not enough is received.
This has been resolved with a modified plComponent (if you are interested in how this is done,
the file plComponent has been commented)
